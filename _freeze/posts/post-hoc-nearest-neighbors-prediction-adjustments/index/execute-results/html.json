{
  "hash": "370a821a2e5f67af52887f48bbf0937e",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: '_Post Hoc_ Nearest Neighbors Prediction Adjustments'\nauthor: 'Max Kuhn'\ndate: '2024-04-07'\ncategories:\n  - post-processing\n  - nearest neighbors\n  - regression\n---\n\n\n<hr>\n \nQuinlan (1993) describes a post-processing technique used for numeric predictions that takes the model's predictions and adjusts it using information from the training set. \n\nLet's say you have some model with outcome $y$ and a vector of predictors $\\boldsymbol{x}$. We've fit some model to the training set and we have a new observation with predictors $\\boldsymbol{x}_0$; the model's prediction is $\\widehat{y}_0$.\n\nThis method finds the $K$-nearest neighbors to $\\boldsymbol{x}_0$ from the training set (denotes as $\\boldsymbol{x}_1\\ldots \\boldsymbol{x}_K$) and their corresponding predictions $\\widehat{y}_i$. The distances from the new sample to the training set points are $d_i$.\n\nFor the new data point, the $K$ adjusted predictions are: \n\n$$\n\\widehat{a}_i = y_i + (\\widehat{y}_0 - \\widehat{y}_i)\n$$\n\nfor $i=1\\ldots K$.  The final prediction is the weighted average the $\\widehat{a}_i$ where the weights are $w_i = 1 / (d_i + \\epsilon)$. $\\epsilon$ is there to prevent division by zero and Quinlan defaults this to 0.5. \n\nThis adjustment is an intregal part of the Cubist rule-based model ensemble that we talk about in _APM_. \n\nTo do this in general, I've started a small R package called [adjusted])https://topepo.github.io/adjusted/). It works off if tidymodels workflow objects and uses Gower distance for calculations. \n\n\nHere's an example using MARS:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidymodels)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n── Attaching packages ────────────────────────────────────── tidymodels 1.2.0 ──\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n✔ broom        1.0.5      ✔ recipes      1.0.10\n✔ dials        1.2.1      ✔ rsample      1.2.1 \n✔ dplyr        1.1.4      ✔ tibble       3.2.1 \n✔ ggplot2      3.5.0      ✔ tidyr        1.3.1 \n✔ infer        1.0.6      ✔ tune         1.2.0 \n✔ modeldata    1.3.0      ✔ workflows    1.1.4 \n✔ parsnip      1.2.1      ✔ workflowsets 1.1.0 \n✔ purrr        1.0.2      ✔ yardstick    1.3.1 \n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n── Conflicts ───────────────────────────────────────── tidymodels_conflicts() ──\n✖ purrr::discard() masks scales::discard()\n✖ dplyr::filter()  masks stats::filter()\n✖ dplyr::lag()     masks stats::lag()\n✖ recipes::step()  masks stats::step()\n• Use suppressPackageStartupMessages() to eliminate package startup messages\n```\n\n\n:::\n\n```{.r .cell-code}\nlibrary(adjusted)\n# Also requires the earth package\ntidymodels_prefer()\ntheme_set(theme_bw())\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndata(deliveries, package = \"modeldata\")\n\nset.seed(991)\ndelivery_split <- initial_validation_split(deliveries, prop = c(0.6, 0.2), strata = time_to_delivery)\ndelivery_train <- training(delivery_split)\ndelivery_test  <- testing(delivery_split)\ndelivery_val   <- validation(delivery_split)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmars_spec <-  \n  mars(prod_degree = 2) %>% \n  set_mode(\"regression\")\n\nmars_fit <- \n  workflow() %>% \n  add_formula(time_to_delivery ~ .) %>% \n  add_model( mars_spec) %>% \n  fit(data = delivery_train)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n\nAttaching package: 'plotrix'\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nThe following object is masked from 'package:scales':\n\n    rescale\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmars_fit %>%\n  extract_fit_engine() %>% \n  format(digits = 3) %>% \n  cat()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  53\n  -  0.456 * dayTue\n  +   3.48 * dayWed\n  +   5.97 * dayThu\n  +   10.6 * dayFri\n  +   15.1 * daySat\n  +   3.68 * daySun\n  -   1.13 * h(hour-16.233)\n  -   2.35 * h(17.319-hour)\n  +  0.466 * h(hour-17.319)\n  -   2.57 * h(3.84-distance)\n  +   3.99 * h(distance-3.84)\n  -  0.563 * h(2-item_02)\n  +   4.22 * h(item_02-2)\n  -  0.554 * h(1-item_03)\n  +  0.851 * h(item_03-1)\n  -   11.6 * h(2-item_10)\n  +   10.4 * h(item_10-2)\n  -  0.807 * h(1-item_24)\n  +  0.581 * h(item_24-1)\n  +  0.869 * h(17.319-hour)*dayTue\n  -  0.656 * h(17.319-hour)*dayThu\n  -   1.57 * h(18.023-hour)*dayFri\n  -   1.39 * h(hour-18.023)*dayFri\n  -    1.7 * h(18.629-hour)*daySat\n  -   2.86 * h(hour-18.629)*daySat\n  +   1.16 * h(distance-3.84)*dayFri\n  -  0.561 * h(5.02-distance)*daySat\n  +    2.1 * h(distance-5.02)*daySat\n  -   11.3 * h(1-item_01)*item_10\n  +   9.95 * h(item_01-1)*item_10\n  -   1.43 * h(1-item_10)*daySat\n  -   2.55 * h(item_10-1)*daySat\n  -  0.578 * h(17.319-hour)*h(distance-3.54)\n  +  0.324 * h(17.319-hour)*h(3.54-distance)\n  +   1.05 * h(1-item_01)*h(item_09-1)\n  -  0.546 * h(1-item_01)*h(1-item_09)\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nadj_obj <- nn_adjust(mars_fit, delivery_train)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nval_pred <- \n  tibble(neighbors = 0:20) %>% \n  mutate(\n    .pred = map(neighbors, \n                ~ predict(adj_obj, new_data = delivery_val, neighbors = .x) %>% bind_cols(delivery_val)),\n    rmse = map_dbl(.pred, ~ rmse_vec(.x$time_to_delivery, .x$.pred))\n  )\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nval_pred %>% \n  ggplot(aes(neighbors, rmse)) +\n  geom_point() + \n  geom_line()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/rmse-1.png){width=576}\n:::\n:::\n\n\nshow bl res and compare\n\n\n::: {.cell}\n\n```{.r .cell-code}\nval_pred_0 <- val_pred %>% filter(neighbors == 0) %>% pluck(\"rmse\")\n\nval_pred %>% \n  mutate(pct_imp = (val_pred_0 - rmse) / val_pred_0) %>% \n  ggplot(aes(neighbors, pct_imp)) +\n  geom_point() + \n  geom_line() + \n  scale_y_continuous(labels = scales::percent)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/res-1.png){width=576}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\npredict(adj_obj, new_data = delivery_test, neighbors = 0) %>% \n  bind_cols(delivery_test) %>% \n  rmse(time_to_delivery, .pred)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 3\n  .metric .estimator .estimate\n  <chr>   <chr>          <dbl>\n1 rmse    standard        2.20\n```\n\n\n:::\n\n```{.r .cell-code}\npredict(adj_obj, new_data = delivery_test, neighbors = 1) %>% \n  bind_cols(delivery_test) %>% \n  rmse(time_to_delivery, .pred)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 3\n  .metric .estimator .estimate\n  <chr>   <chr>          <dbl>\n1 rmse    standard        2.64\n```\n\n\n:::\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}